#pragma kernel CSNormal
#pragma kernel CSCombineNormal

RWTexture2D<float4> Result;
Texture2D<float4> ImageInput;
SamplerState LinearRepeatSample;

float2 _ImageSize;
int _Desaturate;

Texture2D<float4> _BlurTex0;
Texture2D<float4> _BlurTex1;
Texture2D<float4> _BlurTex2;
Texture2D<float4> _BlurTex3;
Texture2D<float4> _BlurTex4;
Texture2D<float4> _BlurTex5;
Texture2D<float4> _BlurTex6;

Texture2D<float4> _LightTex;
Texture2D<float4> _LightBlurTex;

float _ShapeRecognition;
float _LightRotation;
float _ShapeBias;

float _Blur0Weight;
float _Blur1Weight;
float _Blur2Weight;
float _Blur3Weight;
float _Blur4Weight;
float _Blur5Weight;
float _Blur6Weight;
float _BlurContrast;

float _AngularIntensity;
float _Angularity;

float _FinalContrast;
bool _FlipNormalY;

[numthreads(8,8,1)]
void CSNormal (uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy / _ImageSize;
    float2 pixelSize = 1.0 / _ImageSize.xy;
    float4 mainTex = ImageInput[id.xy];
    
    float2 sampleUVDDX = float2(uv.x + pixelSize.x, uv.y);
    float2 sampleUVDDY = float2(uv.x, uv.y + pixelSize.y);
    float4 mainTexDDX = ImageInput.SampleLevel(LinearRepeatSample, sampleUVDDX, 0);
    float4 mainTexDDY = ImageInput.SampleLevel(LinearRepeatSample, sampleUVDDY, 0);
    
    mainTexDDX = mainTexDDX - mainTex;
    mainTexDDY = mainTexDDY - mainTex;
    
    float3 normalTex = normalize( cross( normalize( float3( 1.0, 0.0, mainTexDDX.x * _BlurContrast ) ), normalize( float3( 0.0, 1.0, mainTexDDY.x * _BlurContrast ) ) ) );
    
    half3 heightTex = _LightTex[id.xy].xyz;
    half3 heightBlurTex = _LightBlurTex[id.xy].xyz;
    if( _Desaturate > 0 ){
        heightTex.x = heightTex.x * 0.3 + heightTex.y * 0.5 + heightTex.z * 0.2;
    }
    half HPHeight = ( heightTex.x - heightBlurTex.x ) + _ShapeBias;
    HPHeight = HPHeight * 2.0 - 1.0;
    
    float3 lightDirection = float3( sin( _LightRotation ), cos( _LightRotation ), 0 );
    float3 lightCrossDirection = cross( lightDirection, float3(0,0,1) );
    float3 shape = ( HPHeight * lightDirection ) + ( dot( normalTex, lightCrossDirection ) * lightCrossDirection );
    shape.z = sqrt( 1.0 - saturate( dot(shape.xy, shape.xy ) ) );
    shape = normalize( shape );

    normalTex = normalize( lerp( normalTex, shape, _ShapeRecognition ) );

    normalTex = normalTex * 0.5 + 0.5;

    Result[id.xy] = float4( normalTex, 1.0 );
}

[numthreads(8,8,1)]
void CSCombineNormal (uint3 id : SV_DispatchThreadID)
{
        float2 uv = id.xy / _ImageSize;

		half4 mainTex = half4( _BlurTex0.SampleLevel(LinearRepeatSample, uv, 0).xyz, 1.0 ) * _Blur0Weight;
		half4 blurTex1 = half4( _BlurTex1.SampleLevel(LinearRepeatSample, uv, 0).xyz, 1.0 ) * _Blur1Weight;
		half4 blurTex2 = half4( _BlurTex2.SampleLevel(LinearRepeatSample, uv, 0).xyz, 1.0 ) * _Blur2Weight;
		half4 blurTex3 = half4( _BlurTex3.SampleLevel(LinearRepeatSample, uv, 0).xyz, 1.0 ) * _Blur3Weight;
		half4 blurTex4 = half4( _BlurTex4.SampleLevel(LinearRepeatSample, uv, 0).xyz, 1.0 ) * _Blur4Weight;
		half4 blurTex5 = half4( _BlurTex5.SampleLevel(LinearRepeatSample, uv, 0).xyz, 1.0 ) * _Blur5Weight;
		half4 blurTex6 = half4( _BlurTex6.SampleLevel(LinearRepeatSample, uv, 0).xyz, 1.0 ) * _Blur6Weight;
		
		
		
		mainTex = mainTex + blurTex1 + blurTex2 + blurTex3 + blurTex4 + blurTex5 + blurTex6;
		
		mainTex *= 1.0 / mainTex.w;
		
		mainTex.xyz = normalize( mainTex.xyz * 2.0 - 1.0 );

		float3 angularDir = normalize( float3( normalize( float3( mainTex.xy, 0.001 ) ).xy * _AngularIntensity, max( 1.0 - _AngularIntensity, 0.001 ) ) );
		mainTex.xyz = lerp( mainTex.xyz, angularDir, _Angularity );
		
		mainTex.xy = mainTex.xy * _FinalContrast;
		mainTex.z = pow( saturate( mainTex.z ), _FinalContrast );
		
		mainTex.xyz = normalize( mainTex.xyz ) * 0.5 + 0.5;
		
		if( _FlipNormalY == 0 ){
			mainTex.y = 1.0 - mainTex.y;
		}
		
		Result[id.xy] = float4( mainTex.xyz, 1.0 );
}