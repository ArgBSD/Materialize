#include "Assets/Shaders/Include/Color.hlsl"
#include "Assets/Shaders/Include/Random.hlsl"

#pragma kernel CSBlur
#pragma kernel CSCombineHeight
#pragma kernel CSHeightFromNormal

RWTexture2D<float4> Result;
Texture2D<float4> ImageInput;

Texture2D<float4> _BlendTex;
Texture2D<float4> _AvgTex;
Texture2D<float4> _BlurTex0;
Texture2D<float4> _BlurTex1;
Texture2D<float4> _BlurTex2;
Texture2D<float4> _BlurTex3;
Texture2D<float4> _BlurTex4;
Texture2D<float4> _BlurTex5;
Texture2D<float4> _BlurTex6;

SamplerState LinearRepeatSample;

float _Contrast;
float _BlurContrast;

float _Blur0Weight;
float _Blur0Contrast;

float _Blur1Weight;
float _Blur1Contrast;

float _Blur2Weight;
float _Blur2Contrast;

float _Blur3Weight;
float _Blur3Contrast;

float _Blur4Weight;
float _Blur4Contrast;

float _Blur5Weight;
float _Blur5Contrast;

float _Blur6Weight;
float _Blur6Contrast;

float4 _BlurDirection;
int _BlurSamples;
float _BlurSpread;
float _Spread;
float _SpreadBoost;
float _BlendAmount;

bool _FlipNormalY;
int _Samples;
float _Progress;

float _FinalContrast;
float _FinalBias;
float _FinalGain;

int _Desaturate;
float2 _ImageSize;

bool _HeightFromNormal;

[numthreads(8,8,1)]
void CSBlur (uint3 id : SV_DispatchThreadID)
{
    float2 pixelSize = ( 1.0 / _ImageSize.xy );

    int totalSamples = _BlurSamples * 2;
    int i;
    half4 mainTex = float4(0,0,0,0);
    for( i = -_BlurSamples; i <= _BlurSamples; i++ ){

        float weight = cos( ( float( i ) / float( totalSamples ) ) * 6.28318530718 ) * 0.5 + 0.5;
        float2 uv = id.xy / _ImageSize;
        half4 sampleTex = ImageInput.SampleLevel(LinearRepeatSample, uv + pixelSize.xy * _BlurDirection.xy * i * _BlurSpread, 0);
        if( _Desaturate > 0 ){
            sampleTex.xyz = sampleTex.x * 0.3 + sampleTex.y * 0.5 + sampleTex.z * 0.2;
        }
        sampleTex = half4( sampleTex.xyz * weight, weight );
        mainTex += sampleTex;
    }
    
    mainTex.xyz *= 1.0 / mainTex.w;
    //mainTex.xyz = FastSRGBToLinear(mainTex.xyz);
    mainTex.xyz = saturate( ( ( mainTex.xyz - 0.5 ) * _BlurContrast ) + 0.5 );

    Result[id.xy] = float4(mainTex.xyz, 1.0);
}

[numthreads(8,8,1)]
void CSCombineHeight (uint3 id : SV_DispatchThreadID)
{
    half4 heightTex = half4(0, 0, 0, 0);
    
    if (_HeightFromNormal > 0.5) {
        heightTex = ImageInput[id.xy].xxxx;
    } else {
        float avgColor = pow(abs(_AvgTex[id.xy].x), 0.45 );

        heightTex = half4((pow(abs(_BlurTex0[id.xy].xyz), 0.45) - avgColor) * _Blur0Contrast + 0.5, 1.0) * _Blur0Weight;
        half4 blurTex1 = half4((pow(abs(_BlurTex1[id.xy].xyz), 0.45) - avgColor) * _Blur1Contrast + 0.5, 1.0) * _Blur1Weight;
        half4 blurTex2 = half4((pow(abs(_BlurTex2[id.xy].xyz), 0.45) - avgColor) * _Blur2Contrast + 0.5, 1.0) * _Blur2Weight;
        half4 blurTex3 = half4((pow(abs(_BlurTex3[id.xy].xyz), 0.45) - avgColor) * _Blur3Contrast + 0.5, 1.0) * _Blur3Weight;
        half4 blurTex4 = half4((pow(abs(_BlurTex4[id.xy].xyz), 0.45) - avgColor) * _Blur4Contrast + 0.5, 1.0) * _Blur4Weight;
        half4 blurTex5 = half4((pow(abs(_BlurTex5[id.xy].xyz), 0.45) - avgColor) * _Blur5Contrast + 0.5, 1.0) * _Blur5Weight;
        half4 blurTex6 = half4((pow(abs(_BlurTex6[id.xy].xyz), 0.45) - avgColor) * _Blur6Contrast + 0.5, 1.0) * _Blur6Weight;

        heightTex = heightTex + blurTex1 + blurTex2 + blurTex3 + blurTex4 + blurTex5 + blurTex6;

        heightTex *= 1.0 / heightTex.w;
    }
    
    heightTex.x = saturate(((heightTex.x - 0.5) * _FinalContrast) + 0.5 + _FinalBias);
                
    heightTex.x = saturate( heightTex.x );
    
    if( heightTex.x > 0.5 ){
        heightTex.x = pow( saturate( heightTex.x * 2.0 - 1.0 ), _FinalGain ) * 0.5 + 0.5;
    }else{
        heightTex.x = 1.0 - ( pow( saturate( ( 1.0 - heightTex.x ) * 2.0 - 1.0 ), _FinalGain ) * 0.5 + 0.5 );
    }
        
   Result[id.xy] = float4(heightTex.xxx, 1.0);
}

[numthreads(8,8,1)]
void CSHeightFromNormal (uint3 id : SV_DispatchThreadID)
{
    float2 pixelSize = ( 1.0 / _ImageSize.xy );

    float3 flipTex = float3(1,1,1);
    if( _FlipNormalY){
        flipTex = float3(1,-1,1);
    }
    
    float2 uv = id.xy / _ImageSize;
    
    int AOSamples = _Samples;
    float startOffset = rand_1_05(uv);
    int i;
    
    float2 direction;
    direction.x = sin( _Progress * 6.28318530718 );
    direction.y = cos( _Progress * 6.28318530718 );
    
    float Weight = 0.0;
    float TotalWeight = 0.0;
    float AO = 0.0;
    
    for( i = 1; i <= AOSamples; i++ ) {        
        float passProgress = float(i) / float(AOSamples);
        float2 randomizer = rand_2_10( uv * i )  * passProgress * 0.1;
        float2 uvOffset = direction * _Spread * ( passProgress * _SpreadBoost ) + randomizer;
        float2 trueDir = normalize( uvOffset );
        
        float2 sampleUV = uv + pixelSize.xy * uvOffset;
        half3 sampleTex = ImageInput.SampleLevel(LinearRepeatSample, sampleUV, 0).xyz;

        sampleTex = sampleTex * 2.0 - 1.0;
        sampleTex *= flipTex;
        
        float sampleAO = dot( sampleTex, normalize( float3( trueDir, 0.0 ) ) );
        Weight = 1.0;
        TotalWeight += Weight;
        AO += sampleAO * Weight;        
    }

    AO *= 1.0 / TotalWeight;
    AO *= ( (float)AOSamples * _SpreadBoost ) / 50.0;
    AO = AO * 0.5 + 0.5;
    
    float blendTex = _BlendTex[id.xy].x;
    
    AO = lerp( blendTex, AO, _BlendAmount );
    
    Result[id.xy] = float4( AO.xxx, 1.0 );
}